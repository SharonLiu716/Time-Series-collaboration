#mean_true=matrix(c(1.2,0.6,1.0,0.5), nrow = 1, ncol = 4,byrow = TRUE)
#========================================
#Function of output object
#========================================
#Par.values==TrueMean
Mean.True<-function(Par.values,x.mat){  return(exp(Par.values%*%x.mat))}
Mean.True(Par.values=param_222,x.mat=xmat_222)
Matrix.I<-function(cros.type,params,x.mat){
num.seq<-if (nchar(cros.type)==9) 3 else 2
mat.I<- matrix(0, nrow = length(params), ncol = length(params))
Mean<-Mean.True(Par.values=params,x.mat=x.mat)
for (i in 1:length(params) ){ mat.I[i,]<-Mean%*%(t(x.mat)*x.mat[i,])/num.seq}
return(mat.I)
}
rm(list=ls(all=TRUE))
setwd("C:/Users/User/Documents/Study_CrossoverDesign/RCode")
#=============================================
#simulation parameter
#=============================================
sim_time=5000;cor_par=1
cros_type=c('ABBA','ABBBAA','AABABABAA','ABCBCACAB','BACACBBCA','BBAACBCAC')
#=============================================
#true value of params with treat-seq-time
#=============================================
param_222=c(1.2,0.6,1.0,0.5)
#=================================================
#Link of Yist:Y11,Y12,Y21,Y22
#row is vector of param,column is x.mat of Yist
#=================================================
#ABBAlog(0.5)
xmat_222=matrix(c(1,1,1,1, 0,1,1,0, 0,1,0,1, 0,0,1,1), nrow = 4, ncol = 4,byrow = TRUE)
#mean_true=matrix(c(1.2,0.6,1.0,0.5), nrow = 1, ncol = 4,byrow = TRUE)
#========================================
#Function of output object
#========================================
#Par.values==TrueMean
Mean.True<-function(Par.values,x.mat){  return(exp(Par.values%*%x.mat))}
#Mean.True(Par.values=param_222,x.mat=xmat_222)
mean_true=Mean.True(Par.values=param_222,x.mat=xmat_222)
#I.true
Matrix.I<-function(cros.type,params,x.mat){
num.seq<-if (nchar(cros.type)==9) 3 else 2
mat.I<- matrix(0, nrow = length(params), ncol = length(params))
Mean<-Mean.True(Par.values=params,x.mat=x.mat)
for (i in 1:length(params) ){ mat.I[i,]<-Mean%*%(t(x.mat)*x.mat[i,])/num.seq}
return(mat.I)
}
#======================================================================
#Generate data
#======================================================================
Data.ind<-function(cros.type,mean.true,seq.size){
num.seq<-if (nchar(cros.type)==9) 3 else 2
data <-  matrix(0, nrow = seq.size, ncol = nchar(cros.type))
for (j in 1:length(mean.true)) {data[,j] =rpois(seq.size, lambda = mean.true[1,j])}
return(data)
}
#--------------------------------------------------------------------
Data.cor<-function(cros.type,mean.true,seq.size,cor.par){
num.seq<-if (nchar(cros.type)==9) 3 else 2
nui<-replicate(2,rgamma(n=seq.size,shape=1/cor.par,scale=cor.par))
mean.seq<-matrix(mean.true,ncol=nchar(cros.type)/num.seq,nrow=num.seq)
mean.cor<-list();data <-matrix(0, nrow = seq.size, ncol = nchar(cros.type))
for (i in 1:num.seq){
m<-split(c(outer(nui[,i],mean.seq[,i],  function(x, y) x * y)), ceiling(seq_along(c(outer(nui[,i],mean.seq[,i],  function(x, y) x * y)))/seq.size))
mean.cor<-append(mean.cor,m)
}
mean.cor<- t(matrix(unlist(mean.cor), ncol = seq.size, byrow = TRUE))
for (i in 1:nchar(cros.type)){
list_poisson <- unlist(lapply(mean.cor[,i], FUN = function(x, y) rpois(y, x), y = 1))
data[,i]<-list_poisson
}
return(data)
}
#--------------------------------------------------------------------
#======================================================================
#MLE of different type of crossover design
#======================================================================
##param<-c(tao,eta,gamma,delta)
MLE.ABBA<-function(data){
y.sum=colMeans(data)
tao.hat=log(y.sum[1])
eta.hat=0.5*(log(y.sum[2])+log(y.sum[3])-log(y.sum[1])-log(y.sum[4]))
gamma.hat=0.5*(log(y.sum[2])+log(y.sum[4])-log(y.sum[1])-log(y.sum[3]))
delta.hat=0.5*(log(y.sum[3])+log(y.sum[4])-log(y.sum[1])-log(y.sum[2]))
MLE.i = matrix(c(tao.hat, eta.hat, gamma.hat, delta.hat), nrow=1,ncol=4)
return(MLE.i)
}
#--------------------------------------------------------------------
#I.hat & V.hat
#--------------------------------------------------------------------
Matrix.IV<-function(cros.type,mle.values,x.mat,seq.size,data){
num.seq<-if (nchar(cros.type)==9) 3 else 2
mat.I<- matrix(0, nrow = length(mle.values), ncol = length(mle.values))
mat.V<- matrix(0, nrow = length(mle.values), ncol = length(mle.values))
mat.score<- matrix(0, nrow = seq.size, ncol = length(mle.values))
mean.est<-exp(mle.values%*%x.mat)
for (i in 1:length(mle.values) ){
mat.I[i,]<-mean.est%*%(t(x.mat)*x.mat[i,])/num.seq
mat.score[,i]<-sweep(data, 2, mean.est[1,])%*%x.mat[i,]
mat.V[i,]<- colSums(mat.score*mat.score[,i])/(seq.size*num.seq)
}
mat.V<-Matrix::forceSymmetric(mat.V,uplo="L")
list.IV <- list("I.hat" = mat.I, "V.hat" =mat.V)
return(list.IV)
}
#===================================================================
#Loglikelihood of ABBA,MLE.ABBA under H0,Matrix AB
#===================================================================
loglik.ABBA<-function(param,data){
y.sum=colSums(data)
n=nrow(data)
ll= param[1]*y.sum[1]-n*exp(param[1])
+sum(param[1:3])*y.sum[2]-n*exp(sum(param[1:3]))
+(param[1]+param[2]+param[4])*y.sum[3]-n*exp(param[1]+param[2]+param[4])
+(param[1]+param[3]+param[4])*y.sum[4]-n*exp(param[1]+param[3]+param[4])
return(ll)
}
MLE.ABBAnull<-function(data,seq.size,eta.null){
y.sum=colMeans(data)
tao.hatnull<-log(y.sum[1])
gamma.hatnull=log(y.sum[2])-log(y.sum[1])-eta.null
delta.hatnull=log(y.sum[4])-log(y.sum[2])+eta.null
MLE.i.null = matrix(c(tao.hatnull,  eta.null, gamma.hatnull, delta.hatnull), nrow=1,ncol=4)
return(MLE.i.null)
}
Matrix.AB<-function(Mat.I,Mat.V,loc){
Mat.I<-I.ind.i
diag.I<-as.matrix(diag(Mat.I),byrow = TRUE)
diag.V<-as.matrix(diag(Mat.V),byrow = TRUE)
#I.theta.theta
I.tt<-diag.I[loc];V.tt<-diag.V[loc];I.pp<-Mat.I[-c(loc),-c(loc)];V.pp<-Mat.V[-c(loc),-c(loc)]
I.tp<-as.matrix(Mat.I[loc,]);I.tp<-as.matrix(I.tp[-c(loc),]);V.tp<-as.matrix(Mat.V[loc,]);V.tp<-as.matrix(V.tp[-c(loc),])
#mat.A
Mat.A<-I.tt-t(I.tp)%*%solve(I.pp)%*%I.tp
Mat.B<-V.tt-2*t(I.tp)%*%solve(I.pp)%*%V.tp+t(I.tp)%*%solve(I.pp)%*%V.pp%*%solve(I.pp)%*%I.tp
Mat.AB<- list("Mat.A" = Mat.A, "Mat.B" =Mat.B)
return(Mat.AB)
}
#========================================
#main
#result:to store result of each seq_size
#========================================
result.ind <- list();result.cor <- list();pvalue.ind<-list();pvalue.cor<-list()
#simulation for ABBA
seq=100
MLE.ind<-matrix(0, nrow = sim_time, ncol = length(param_222))
MLE.cor<-matrix(0, nrow = sim_time, ncol = length(param_222))
MLE.null.ind<-matrix(0, nrow = sim_time, ncol = length(param_222))
MLE.null.cor<-matrix(0, nrow = sim_time, ncol = length(param_222))
I.ind<- 0 ; I.cor<- 0 ; V.ind<-0 ;V.cor<-0;invI.ind<-0;invI.cor<-0
# Create df for statistics
statistics.columns <- c("Wald.na","Wald.rb",'Score.na','Score.rb',"LR.na")
df.statistics.ind <- data.frame(matrix(nrow = sim_time, ncol = length(statistics.columns)))
colnames(df.statistics.ind) <- statistics.columns
df.statistics.cor = data.frame(matrix(nrow = sim_time, ncol = length(statistics.columns)))
colnames(df.statistics.cor) <- statistics.columns
matA.ind<-c();matB.ind<-c();matA.cor<-c();matB.cor<-c();matA.ind.null<-c();matB.ind.null<-c();matA.cor.null<-c();matB.cor.null<-c()
indt.A<-c();indt.B<-c();indg.A<-c();indg.B<-c();indd.A<-c();indd.B<-c()
cort.A<-c();cort.B<-c();corg.A<-c();corg.B<-c();cord.A<-c();cord.B<-c()
set.seed(7353)
for (i in 1:sim_time){
#====================================================
#I,V,IVI
#====================================================
theta.null=0.6
# X = c(rep(0,seq), rep(1,2*seq), rep(0,seq))
# Z = c(rep(0,seq), rep(1,seq), rep(0,seq), rep(1,seq))
# G = c(rep(0,2*seq), rep(1,2*seq))
#independent
data.ind<-Data.ind(cros.type = cros_type[1],mean.true =mean_true,seq.size = seq )
#use package to do testing
# Y <- c(data.ind[,1],data.ind[,2],data.ind[,3],data.ind[,4])
# df.ind = data.frame(Y,X,Z,G)
# mod.1 <- glm(Y ~ X + Z + G, family = poisson(link = "log"), df.ind)
# mod.0 <- glm(Y ~ Z + G, family = poisson(link = "log"), df.ind)
# MLE.ind[i,]<-c( mod.1$coefficients[1],mod.1$coefficients[2],mod.1$coefficients[3],mod.1$coefficients[4])#MLE.ABBA(data.ind)
# MLE.null.ind[i,]<-c( mod.0$coefficients[1],theta.null,mod.0$coefficients[2],mod.0$coefficients[3])#MLE.ABBAnull(data = data.ind, seq.size = seq, eta.null=theta.null)
#
#use closeform to do testing
MLE.ind[i,]<- MLE.ABBA(data.ind)
MLE.null.ind[i,]<-MLE.ABBAnull(data = data.ind, seq.size = seq, eta.null=theta.null)
mean.est<-Mean.True(MLE.ind[i,],xmat_222)
IV.ind.i<-Matrix.IV(cros.type=cros_type[1], mle.values=MLE.ind[i,], x.mat=xmat_222, seq.size=seq, data=data.ind)
#correlated
data.cor<-Data.cor(cros.type = cros_type[1],mean.true =mean_true,seq.size =seq,cor.par = cor_par )
#use package to do testing
# Y <- c(data.cor[,1],data.cor[,2],data.cor[,3],data.cor[,4])
# df.cor = data.frame(Y,X,Z,G)
# mod.1 <- glm(Y ~ X + Z + G, family = poisson(link = "log"), df.cor)
# mod.0 <- glm(Y ~ Z + G, family = poisson(link = "log"), df.cor)
# MLE.cor[i,]<-c( mod.1$coefficients[1],mod.1$coefficients[2],mod.1$coefficients[3],mod.1$coefficients[4])
# MLE.null.cor[i,]<-c( mod.0$coefficients[1],theta.null,mod.0$coefficients[2],mod.0$coefficients[3])
MLE.cor[i,]<- MLE.ABBA(data.cor)
MLE.null.cor[i,]<- MLE.ABBAnull(data = data.cor, seq.size = seq, eta.null=theta.null)
mean.est<-Mean.True(MLE.cor[i,],xmat_222)
IV.cor.i<-Matrix.IV(cros.type=cros_type[1], mle.values=MLE.cor[i,], x.mat=xmat_222, seq.size=seq, data=data.cor)
#store result of MLE,I,V,inv.I
I.ind.i<-IV.ind.i$I.hat
V.ind.i<-Matrix::forceSymmetric(IV.ind.i$V.hat,uplo="L")
invI.ind.i<-solve(I.ind.i)
I.ind<-I.ind+I.ind.i
V.ind<-V.ind+V.ind.i
invI.ind<-invI.ind+invI.ind.i
I.cor.i<-IV.cor.i$I.hat
V.cor.i<-Matrix::forceSymmetric(IV.cor.i$V.hat,uplo="L")
invI.cor.i<-solve(I.cor.i)
I.cor<-I.cor+I.cor.i
V.cor<-V.cor+V.cor.i
invI.cor<-invI.cor+invI.cor.i
#=========================================================================
#output:matrix AB, Wald statistics,LR statistics, Score statistics
#=========================================================================
matA.ind[i]<-Matrix.AB(I.ind.i,as.matrix(V.ind.i),2)$Mat.A
matB.ind[i]<-Matrix.AB(I.ind.i,as.matrix(V.ind.i),2)$Mat.B
indt.A[i]<-Matrix.AB(I.ind.i,as.matrix(V.ind.i),1)$Mat.A
indt.B[i]<-Matrix.AB(I.ind.i,as.matrix(V.ind.i),1)$Mat.B
indg.A[i]<-Matrix.AB(I.ind.i,as.matrix(V.ind.i),3)$Mat.A
indg.B[i]<-Matrix.AB(I.ind.i,as.matrix(V.ind.i),3)$Mat.B
indd.A[i]<-Matrix.AB(I.ind.i,as.matrix(V.ind.i),4)$Mat.A
indd.B[i]<-Matrix.AB(I.ind.i,as.matrix(V.ind.i),4)$Mat.B
IV.ind.null<-Matrix.IV(cros.type=cros_type[1], mle.values=MLE.null.ind[i,], x.mat=xmat_222, seq.size=seq, data=data.cor)
I.ind.null<-IV.ind.null$I.hat
V.ind.null<-Matrix::forceSymmetric(IV.ind.null$V.hat,uplo="L")
invI.ind.i<-solve(I.ind.null)
matA.ind.null[i]<-Matrix.AB(I.ind.null,as.matrix(V.ind.null),2)$Mat.A
matB.ind.null[i]<-Matrix.AB(I.ind.null,as.matrix(V.ind.null),2)$Mat.B
df.statistics.ind[i, "Wald.na"] <- seq*2*matA.ind[i]*(MLE.ind[i,2]-theta.null)^2
df.statistics.ind[i, "Wald.rb"] <- seq*2*(matA.ind[i]^2)/matB.ind[i]*((MLE.ind[i,2]-theta.null)^2)
df.statistics.ind[i, "LR.na"] <- 2*(loglik.ABBA(param = MLE.ind[i,],data = data.ind)-loglik.ABBA(param = as.vector(MLE.null.ind[i,]),data = data.ind))
# df.statistics.ind[i, "LR.rb"] <- 2*matA.ind.i[i]/matB.ind.i[i]*(loglik.ABBA(param = MLE.ind.i,data = data.ind)-loglik.ABBA(param = as.vector(MLE.null),data = data.ind))
mean.null<-Mean.True(MLE.null.ind[i,],xmat_222)
df.statistics.ind[i, "Score.na"] <- (sum(data.ind[,2]-mean.null[,2])+sum(data.ind[,3]-mean.null[,3]))^2 / (matA.ind.null[i]*seq*2)
df.statistics.ind[i, "Score.rb"] <- (sum(data.ind[,2]-mean.null[,2])+sum(data.ind[,3]-mean.null[,3]))^2 / (matB.ind.null[i]*seq*2)
# #wald.test(Sigma = cov(MLE.ind), b = t(MLE.ind.i), Terms = 2)
matA.cor[i]<-Matrix.AB(I.cor.i,as.matrix(V.cor.i),2)$Mat.A
matB.cor[i]<-Matrix.AB(I.cor.i,as.matrix(V.cor.i),2)$Mat.B
cort.A[i]<-Matrix.AB(I.ind.i,as.matrix(V.cor.i),1)$Mat.A
cort.B[i]<-Matrix.AB(I.ind.i,as.matrix(V.cor.i),1)$Mat.B
corg.A[i]<-Matrix.AB(I.ind.i,as.matrix(V.cor.i),3)$Mat.A
corg.B[i]<-Matrix.AB(I.ind.i,as.matrix(V.cor.i),3)$Mat.B
cord.A[i]<-Matrix.AB(I.ind.i,as.matrix(V.cor.i),4)$Mat.A
cord.B[i]<-Matrix.AB(I.ind.i,as.matrix(V.cor.i),4)$Mat.B
IV.cor.null<-Matrix.IV(cros.type=cros_type[1], mle.values=MLE.null.cor[i,], x.mat=xmat_222, seq.size=seq, data=data.cor)
I.cor.null<-IV.cor.null$I.hat
V.cor.null<-Matrix::forceSymmetric(IV.cor.null$V.hat,uplo="L")
invI.cor.i<-solve(I.cor.null)
matA.cor.null[i]<-Matrix.AB(I.cor.null,as.matrix(V.cor.null),2)$Mat.A
matB.cor.null[i]<-Matrix.AB(I.cor.null,as.matrix(V.cor.null),2)$Mat.B
df.statistics.cor[i, "Wald.na"] <- seq*2*matA.cor[i]*(MLE.cor[i,2]-theta.null)^2
df.statistics.cor[i, "Wald.rb"] <- seq*2*(matA.cor[i]^2)/matB.cor[i]*((MLE.cor[i,2]-theta.null)^2)
df.statistics.cor[i, "LR.na"] <- 2*(loglik.ABBA(param = MLE.cor[i,],data = data.cor)-loglik.ABBA(param = as.vector(MLE.null.cor[i,]),data = data.cor))
# df.statistics.cor[i, "LR.rb"] <- 2*matA.cor[i]/matB.cor[i]*(loglik.ABBA(param = MLE.cor.i,data = data.cor)-loglik.ABBA(param = as.vector(MLE.null),data = data.cor))
mean.null<-Mean.True(MLE.null.cor[i,],xmat_222)
df.statistics.cor[i, "Score.na"] <- (sum(data.cor[,2]-mean.null[,2])+sum(data.cor[,3]-mean.null[,3]))^2 / (matA.cor.null[i]*seq*2)
df.statistics.cor[i, "Score.rb"] <- (sum(data.cor[,2]-mean.null[,2])+sum(data.cor[,3]-mean.null[,3]))^2 / (matB.cor.null[i]*seq*2)
# #Wald.naive
# Wald.na.ind<-seq.size*2*Mat.A*(theta.hat-theta.null)^2
# #Wald.robust
# Wald.rb<-seq.size*2*(Mat.A^2)*((theta.hat-theta.null)^2)/Mat.B
# #LR.naive
# MLE.null<-MLE.ABBAnull(data = data.ind, seq.size = seq,eta.null=0)
# LR.na<-2*(loglik.ABBA(param = MLE.ind.i,data = data.ind)-loglik.ABBA(param = as.vector(MLE.null),data = data.ind))
# #LR.robust
# LR.rb<-2*Mat.A*(loglik.ABBA(param = MLE.ind.i,data = data.ind)-loglik.ABBA(param = as.vector(MLE.null),data = data.ind))/Mat.B
#
}
cov(MLE.ind)*2*seq
setwd("C:/Github/Data-Analysis-Practice/Time Series/Lecture/hw2") # set working directory
setwd("C:/Users/User/Documents/Time-Series-collaboration") # set working directory
library(zoo)
library(xts)
library(TTR)
library(quantmod)
#plot packages
library(ggplot2)
library(magrittr)
library(broom)
#install.packages("fpp2")                            # Install qpcR package
library(qpcR)
library(fpp2)
getSymbols("^VIX", from = '2012-10-12', to = '2022-10-12')
VIX<-as.xts(data.frame(TWII = TWII[, "TWII.Adjusted"]))
getSymbols("^VIX", from = '2012-10-12', to = '2022-10-12')
VIX<-as.xts(data.frame(VIX = VIX[, "VIX.Adjusted"]))
VIX<-na.omit(VIX)
names(VIX) = c("VIX")
index(VIX) = as.Date(index(VIX))
#==========================================
#Get original data
#==========================================
rt.VIX<-apply( VIX , 2 , diff )*100
rttp.VIX=tidy(as.xts(rt.VIX)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(logrt.TWII),"Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
rt.VIX<-apply( VIX , 2 , diff )*100
rttp.VIX=tidy(as.xts(rt.VIX)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(rt.VIX),"Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
rttp.VIX
rt.VIX<-VIX
rttp.VIX=tidy(as.xts(rt.VIX)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(rt.VIX),"Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
rttp.VIX
setwd("C:/Users/User/Documents/Time-Series-collaboration") # set working directory
library(zoo)
library(xts)
library(TTR)
library(quantmod)
#plot packages
library(ggplot2)
library(magrittr)
library(broom)
#install.packages("fpp2")                            # Install qpcR package
library(qpcR)
library(fpp2)
#start<-paste0(as.numeric(format(Sys.Date(), "%Y"))-11,format(Sys.Date(), "-%m-%d"))
#===============================================================
#Get stocks price
#===============================================================
#VIX
getSymbols("^VIX", from = '2012-10-12', to = '2022-10-12')
VIX<-as.xts(data.frame(VIX = VIX[, "VIX.Adjusted"]))
VIX<-na.omit(VIX)
names(VIX) = c("VIX")
index(VIX) = as.Date(index(VIX))
#==========================================
#Get original data
#==========================================
rt.VIX<-VIX
rttp.VIX=tidy(as.xts(rt.VIX)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(rt.VIX),"Stock Price for 10 years"),subtitle = "Stock Price",caption = " Time Plot") +
xlab("Date") + ylab("Stock Price in Percentage")
rttp.VIX
ggsave(paste(colnames(rt.VIX),"Stock Price time plot.png"), plot = rttp.VIX)
#==========================================
#Get daily log return and time plots
#==========================================
logrt.VIX<-apply( log(VIX) , 2 , diff )*100
logrttp.VIX=tidy(as.xts(logrt.VIX)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(logrt.TWII),"Log Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
logres.VIX<-modle.MLE(as.numeric(logrt.VIX))
modle.MLE<-function(data){
m1 = ar(data, method="mle")
m1$aic
m1$order
m2 = arima(data, order=c(m1$order,0,0))
m2
phi0_hat = (1-sum(m2$coef[1:m1$order]))*m2$coef[m1$order+1]
phi0_hat
sqrt(m2$sigma2)
bt<-Box.test(m2$residuals, lag=10, type='Ljung')
par(mfrow = c(3,1))
plot(1:length(m2$residuals), m2$residuals, type='l')
abline(a = 0, b = 0, col = 2)
acf(m2$residuals)
pacf(m2$residuals)
tsdiag(m2, gof=floor(log(T))+1)
p1    = c(1,-m2$coef[1:m1$order])
roots = polyroot(p1)
roots
modulus = Mod(roots)
modulus
k = 2*pi/acos(Re(roots[1])/modulus[1])
k
res<-list()
objs<-c("AIC","mle.order","m1","m2","Residual Box Test","phi0_hat","sigma2","roots","modulus","business cycle")
res.num<-list(m1$aic,m1$order,m1,m2,bt,phi0_hat,sqrt(m2$sigma2),roots ,modulus,k )
for (i in 1:length(res.num)){res[objs[i]] <- res.num[i]}
return(res)
}
logres.VIX<-modle.MLE(as.numeric(logrt.VIX))
logres.VIX
modle.MLE(as.numeric(logrt.VIX))
modle.MLE(as.numeric(logrt.VIX))
modle.MLE(as.numeric(rt.VIX))
modle.MLE(as.numeric(logrt.VIX))
getSymbols("^HSI", from = '2012-11-28', to = '2022-11-28')
HSI<-as.xts(data.frame(HSI = HSI[, "HSI.Adjusted"]))
HSI<-na.omit(HSI)
names(HSI) = c("HSI")
index(HSI) = as.Date(index(HSI))
rt.HSI<-HSI
rttp.HSI=tidy(as.xts(rt.HSI)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(rt.HSI),"Stock Price for 10 years"),subtitle = "Stock Price",caption = " Time Plot") +
xlab("Date") + ylab("Stock Price in Percentage")
rttp.HSI
logrt.HSI<-apply( log(HSI) , 2 , diff )*100
logrttp.HSI=tidy(as.xts(logrt.HSI)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(logrt.HSI),"Log Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
logrttp.HSI
res<-function(data,name){
jpeg(paste("ACF & PACF","of",name,".jpg"))
par(mfrow = c(2,1))
p1<-acf(data, lag.max = log(length(data)), plot = FALSE)
plot(p1, main = paste("ACF","of",name))
p2<-pacf(data, plot = FALSE)
plot(p2, main = paste("PACF","of",name))
dev.off()
Box.test(data, lag=10, type='Ljung')
}
#ggAcf(logrt.SP500,lag.max =log(length(logrt.SP500))) + labs(title = "ACF PLot of SP500")
#-------------------------------------------
#plot acf & pacf for stocks log return
#-------------------------------------------
res(logrt.HSI,"HSI log return")
res(rt.HSI,"HSI log return")
modle.MLE<-function(data){
m1 = ar(data, method="mle")
m1$aic
m1$order
m2 = arima(data, order=c(m1$order,0,0))
m2
phi0_hat = (1-sum(m2$coef[1:m1$order]))*m2$coef[m1$order+1]
phi0_hat
sqrt(m2$sigma2)
bt<-Box.test(m2$residuals, lag=10, type='Ljung')
par(mfrow = c(3,1))
plot(1:length(m2$residuals), m2$residuals, type='l')
abline(a = 0, b = 0, col = 2)
acf(m2$residuals)
pacf(m2$residuals)
tsdiag(m2, gof=floor(log(T))+1)
p1    = c(1,-m2$coef[1:m1$order])
roots = polyroot(p1)
roots
modulus = Mod(roots)
modulus
k = 2*pi/acos(Re(roots[1])/modulus[1])
k
res<-list()
objs<-c("AIC","mle.order","m1","m2","Residual Box Test","phi0_hat","sigma2","roots","modulus","business cycle")
res.num<-list(m1$aic,m1$order,m1,m2,bt,phi0_hat,sqrt(m2$sigma2),roots ,modulus,k )
for (i in 1:length(res.num)){res[objs[i]] <- res.num[i]}
return(res)
}
adfTest(rt.HSI, type="nc")
library(fUnitRoots)
install.packages("fUnitRoots")
library(fUnitRoots)
adfTest(rt.HSI, type="nc")
adfTest(rt.HSI, type="c")
adfTest(rt.HSI, type="ct")
#==========================================
#Get daily log return and time plots
#==========================================
logrt.HSI<- log(HSI)
logrttp.HSI=tidy(as.xts(logrt.HSI)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(logrt.HSI),"Log Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
logrttp.HSI
logrt.VIX<-log(VIX)
logrttp.VIX=tidy(as.xts(logrt.VIX)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(logrt.VIX),"Log Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
logrttp.VIX
adfTest(logrt.HSI, type="c")
adfTest(logrt.VIX, type="c")
adfTest(logrt.HSI, type="nc")
m1   = ar(diff(logrt.VIX), method = 'mle')
m1   = ar(diff(as.numeric(logrt.VIX)), method = 'mle')
par(mfrow = c(2,3))
plot(1:length(logrt.VIX), logrt.VIX, type='l', main="VIX")
acf(logrt.VIX, main="logrt.VIX")
pacf(logrt.VIX, main="logrt.VIX")
plot(1:(length(logrt.VIX)-1), diff(as.numeric(logrt.VIX)), type='l', main="diff(as.numeric(logrt.VIX))")
abline(a = mean(diff(as.numeric(logrt.VIX))), b = 0, col = 2)
acf(diff(as.numeric(logrt.VIX)), main="diff(as.numeric(logrt.VIX))")
pacf(diff(as.numeric(logrt.VIX)), main="diff(as.numeric(logrt.VIX))")
adfTest(diff(as.numeric(logrt.VIX)), lags = m1$order, type = "c")
logres.VIX<-modle.MLE(as.numeric(logrt.VIX))
logres.VIX<-modle.MLE(diff(as.numeric(logrt.VIX)))
res.VIX<-modle.MLE(diff(as.numeric(logrt.VIX)))
logres.VIX
adfTest(diff(as.numeric(logrt.VIX)), lags = m1$order, type = "ct")
adfTest(diff(as.numeric(logrt.VIX)), lags = m1$order, type = "nc")
adfTest(logrt.HSI, type="c")
getSymbols("^N225", from = '2012-11-28', to = '2022-11-28')
N225<-as.xts(data.frame(N225 = N225[, "N225.Adjusted"]))
N225<-na.omit(N225)
names(N225) = c("N225")
index(N225) = as.Date(index(N225))
rt.N225<-N225
rttp.N225=tidy(as.xts(rt.N225)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(rt.N225),"Stock Price for 10 years"),subtitle = "Stock Price",caption = " Time Plot") +
xlab("Date") + ylab("Stock Price in Percentage")
rttp.N225
logrt.N225<- log(N225)
logrttp.N225=tidy(as.xts(logrt.N225)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(logrt.N225),"Log Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
logrttp.N225
res(rt.N225,"N225 stock price")
#ggAcf(logrt.SP500,lag.max =log(length(logrt.SP500))) + labs(title = "ACF PLot of SP500")
#-------------------------------------------
#plot acf & pacf for stocks log return
#-------------------------------------------
res(logrt.N225,"N225 log return")
logres.N225<-modle.MLE(as.numeric(logrt.N225))
