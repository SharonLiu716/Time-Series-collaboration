---
title: "T.S Final Project"
author: "110225007房錚、110225013劉彥劭、110225021劉懿萱"
date: "`r Sys.Date()`"
output: 
  html_document: 
    theme: journal
    highlight: pygments
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
---
<style type="text/css">
body{ 
  font-size: 16px; 
  } 
  
h1 { 
  font-size: 28px;
  color: saddleBrown;
  } 
  
h2 { 
  font-size: 24px;
  color:orangeRed;
  } 
  
h3 { 
  font-size: 20px;
  color: goldenRod;
  }
  
code.r {
  font-size: 16px;
  }
  
pre {
  font-size: 16px;
  color: darkSlateGray;
}
</style>


# 原始資料說明與建模流程{.tabset .tabset-fade .tabset-pills}

此次選擇標準普爾(以下SP500代稱)、日經平均指數(以下以N225代稱)、紐西蘭NZX50指數(以下NZ50代稱)，於2012-10-12至2022-10-12十年期間的股價日資料進行資料分析與建模。美金對紐西蘭匯率(以下以USDNZD代稱)、美金對日幣匯率(以下以USDJPY代稱)與紐西蘭對日本匯率(以下以NZDJPY代稱)，於2012-10-12到2022-10-12這段時間內的日資料，分別繪製其報酬率與對數報酬率的time plot、ACF與PACF，並對資料進行Ljung Box Test，看資料是否有序列相關或Arch效應，若有序列相關或Arch效應將更進一步建立AR模型或Garch模型，並於建模後做殘差檢定、分析及預測。

```{r setup, include=FALSE}
rm(list=ls(all=TRUE)) 
library(zoo)
library(xts)
library(TTR)
library(quantmod)# Finance data
library(ggplot2)
library(magrittr)
library(broom)
library(qpcR)   
library(fpp2)
library(fUnitRoots)
library(stats)
library(fGarch)

detect <- function(data,p,q){
  temp <- c()
  ord <- c()
  for (i in 0:p) {
    for (j in 0:q) {
      if (i == 0 & j==0) next
      temp <- c(temp,arima(data,order = c(i,0,j))$aic)
      ord <- rbind(ord, c(i,0,j))
    }
  }
  list(likelihood = sort(temp),order = ord[order(temp), ])
}
res <- function(data,obj,cho){
  
  ACF<-acf(data, lag.max = 30,plot = FALSE)
  plot(ACF, main = paste("ACF of",obj))
  PACF<-pacf(data, lag.max = 30,plot = FALSE)
  plot(PACF, main = paste("PACF of",obj))
  
  if (cho == 't'){ACF2<-acf(data^2, lag.max = 30,plot = FALSE)
                plot(ACF2, main = paste("ACF of",obj,'^2'))}
  par(mfrow=c(1,1))
  plot(as.xts(data),main= paste("Time Plot of",obj))
  
}
knitr::opts_chunk$set(echo = FALSE,warning=FALSE)
```

# 原始資料說明與time plot、ACF、PACF繪製{.tabset .tabset-fade .tabset-pills}

- Timeplot、ACF、PACF:stationary

- Box Test:
  
  p-value<0.05 exist correlation
  
- ADF Test for NZ50:

  對原始資料做ADF test，若p-value<0.05不差分，反之，需差分。


## NZ50


```{r, echo=FALSE,warning=FALSE}
getSymbols("^NZ50", from ='2012-12-12', to = '2022-12-12')
NZ50 <- as.xts(data.frame(NZ50 = NZ50[, "NZ50.Adjusted"]))
NZ50 <- na.omit(NZ50)
names(NZ50) = c("NZ50")
index(NZ50) = as.Date(index(NZ50))
res(NZ50,'original NZ50','f')
Box.test(NZ50, lag=10, type='Ljung')
adfTest(NZ50,type = "ct")
```


## USDNZD


```{r, echo=FALSE,warning=FALSE}
getSymbols("USDNZD=X", from = '2012-10-12', to = '2022-10-12')
USDNZD<-as.xts(data.frame(`USDNZD=X` = `USDNZD=X`[, paste0("USDNZD=X.Adjusted")]))
USDNZD<-na.omit(USDNZD)
names(USDNZD) = c("USDNZD")
index(USDNZD) = as.Date(index(USDNZD))
res(USDNZD,'original USDNZD','f')

Box.test(USDNZD, lag=10, type='Ljung')
adfTest(USDNZD,type = "ct")

```


# 模型建立{.tabset .tabset-fade .tabset-pills}
  
  將原始資料取對數後再進行差分，重新畫time plot、ACF、PACF，並做Ljung Box Test與ADF Test。
  從Ljung Box Test的結果與ACF、PACF觀察轉換後的資料是否存在一階與二階序列相關，若存在一階序列相關可從ACF、PACF判斷ARMA(p,q)的order p與q；若存在二階序列相關可以Garch(1,0)開始建模，並於建模後對殘差做Ljung Box Test，若存在一階與二階序列相關則結合ARMA(p,q)與Garch(m,s)進行建模。
  每次建模後若ARMA(p,q)的係數不顯著則調整ARMA(p,q)的order，若residual^2的Ljung Box存在序列相關則調整Garch(m,s)的order。

- ADF Test for diff(log(original data))
  
  將原始資料做log轉換後進行一次差分，並對log轉換後一次差分的資料做ADF Test，若p-value<0.05不差分。
  
- Series Time Plot、ACF、PACF、Series^2 ACF

  Time Plot
  ACF、PACF: order p、q
  Series^2 ACF: whether Garch effect exists or not 
  
- Box Test for diff(log(original data)) & diff(log(original data))^2

  檢定資料是否有序列相關，若p-value<0.05則資料存在序列相關，若次方後的資料p-value<0.05則可能有Garch Effect。

## NZ50

```{r, echo=FALSE,warning=FALSE}
logrt.NZ50 <- apply( log(NZ50) , 2 , diff )*100
res(logrt.NZ50,'log return of NZ50','t')
adfTest(logrt.NZ50,type = "ct")
Box.test(logrt.NZ50, lag=10, type='Ljung')
Box.test(logrt.NZ50^2, lag=10, type='Ljung')
```


### Model ARMA(p,q) and residual diagnostic

```{r, echo=FALSE,warning=FALSE,include = FALSE}
detect(logrt.NZ50, p = 9, q = 3)

```

```{r, echo=FALSE,warning=FALSE}

fit.NZ50 <- arima(logrt.NZ50, order = c(4,0,2))
fit.NZ50
Residual<-fit.NZ50$residuals
res(Residual,'Residual of ARIMA(4,1,2)for log NZ50','t')
Box.test(Residual, lag = 12, type='Ljung')
Box.test(Residual^2, lag = 12, type='Ljung')
```
### Model ARMA(4,2)+Garch(1,0) and residual diagnostic
```{r,echo=FALSE,warning=FALSE}
mod.NZ50 = garchFit(logrt.NZ50~arma(4,2) + garch(1,0), data = logrt.NZ50, trace = FALSE)
summary(mod.NZ50)
plot(mod.NZ50 ,which = 10)
plot(mod.NZ50 ,which = 11)
plot(mod.NZ50 ,which = 13)

res.NZ50 = residuals(mod.NZ50, standardize = T)
Box.test(res.NZ50, lag = 12, type='Ljung')
Box.test(res.NZ50^2, lag = 12, type='Ljung')

```

### Model ARMA(4,2)+Garch(1,1) and residual diagnostic
```{r, echo=FALSE,warning=FALSE}
mod.NZ50 = garchFit(logrt.NZ50~arma(4,2) + garch(1,1), data = logrt.NZ50, trace = FALSE)
summary(mod.NZ50)
plot(mod.NZ50 ,which = 10)
plot(mod.NZ50 ,which = 11)
plot(mod.NZ50 ,which = 13)

res.NZ50 = residuals(mod.NZ50, standardize = T)
Box.test(res.NZ50, lag = 12, type='Ljung')
Box.test(res.NZ50^2, lag = 12, type='Ljung')

```


### Model ARMA(4,2)+Garch(1,1) and  assume residual is from standardize T distribution

```{r, echo=FALSE,warning=FALSE}

mod.NZ50 = garchFit(logrt.NZ50~arma(4,2) + garch(1,1), data = logrt.NZ50, trace = FALSE,cond.dist = 'sstd')
summary(mod.NZ50)
plot(mod.NZ50 ,which = 10)
plot(mod.NZ50 ,which = 11)
plot(mod.NZ50 ,which = 13)

res.NZ50 = residuals(mod.NZ50, standardize = T)
Box.test(res.NZ50, lag = 12, type='Ljung')
Box.test(res.NZ50^2, lag = 12, type='Ljung')

```


### KS Test for residual
```{r,echo=FALSE,warning=FALSE}
set.seed(110225013)
sstd<-rsstd(1000, nu =  7.717256, xi =  0.912625)
ks.test(res.NZ50,sstd)
```



### Predict

```{r, echo=FALSE,warning=FALSE}
#predict(mod.NZ50, 5)
```




## USDNZD

```{r, echo=FALSE,warning=FALSE}

logrt.USDNZD<-apply( log(USDNZD) , 2 , diff )*100
res(logrt.USDNZD,'log return of USDNZD','t')
adfTest(logrt.USDNZD,type = "ct")
Box.test(logrt.USDNZD, lag=10, type='Ljung')
Box.test(logrt.USDNZD^2, lag=10, type='Ljung')

```

### Model Garch(1,0) and residual diagnostic

```{r, echo=FALSE,warning=FALSE}
mod.USDNZD<-garchFit(logrt.USDNZD~ garch(1,0), data = logrt.USDNZD, trace = FALSE)
summary(mod.USDNZD)
plot(mod.USDNZD ,which = 10)
plot(mod.USDNZD ,which = 11)
plot(mod.USDNZD ,which = 13)

res.USDNZD = residuals(mod.USDNZD, standardize = T)
Box.test(res.USDNZD, lag = 12, type='Ljung')
Box.test(res.USDNZD^2, lag = 12, type='Ljung')
```
### Model Garch(1,1) and residual diagnostic
```{r, echo=FALSE,warning=FALSE}
mod.USDNZD<-garchFit(logrt.USDNZD~ garch(1,1), data = logrt.USDNZD, trace = FALSE)
summary(mod.USDNZD)
plot(mod.USDNZD ,which = 10)
plot(mod.USDNZD ,which = 11)
plot(mod.USDNZD ,which = 13)


res.USDNZD = residuals(mod.USDNZD, standardize = T)
Box.test(res.USDNZD, lag = 10, type='Ljung')
Box.test(res.USDNZD^2, lag = 10, type='Ljung')

```

### Model Garch(1,1) and residual diagnostic(assume residual is from standardize T distribution) 
```{r, echo=FALSE,warning=FALSE}
mod.USDNZD<-garchFit(logrt.USDNZD~ garch(1,1), data = logrt.USDNZD, trace = FALSE,cond.dist = 'sstd')
summary(mod.USDNZD)
plot(mod.USDNZD ,which = 10)
plot(mod.USDNZD ,which = 11)
plot(mod.USDNZD ,which = 13)

res.USDNZD = residuals(mod.USDNZD, standardize = T)
Box.test(res.USDNZD, lag = 10, type='Ljung')
Box.test(res.USDNZD^2, lag = 10, type='Ljung')

```

### KS Test for residual
```{r,echo=FALSE,warning=FALSE}
set.seed(110225013)
sstd<-rsstd(1000, nu =  10, xi =  1.085443)
ks.test(res.USDNZD,sstd)
```

### Predict

```{r,echo=FALSE,warning=FALSE}
#predict(mod.USDNZD, 5)
```


# 結論{.tabset .tabset-fade .tabset-pills}
 
 
## NZ50

## USDNZD
