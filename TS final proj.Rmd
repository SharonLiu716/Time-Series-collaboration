---
title: "T.S Final Project"
author: "110225007房錚、110225013劉彥劭、110225021劉懿萱"
date: "`r Sys.Date()`"
output: 
  html_document: 
    theme: journal
    highlight: pygments
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
---
<style type="text/css">
body{ 
  font-size: 16px; 
  } 
  
h1 { 
  font-size: 28px;
  color: saddleBrown;
  } 
  
h2 { 
  font-size: 24px;
  color:orangeRed;
  } 
  
h3 { 
  font-size: 20px;
  color: goldenRod;
  }
  
code.r {
  font-size: 16px;
  }
  
pre {
  font-size: 16px;
  color: darkSlateGray;
}
</style>


# 原始資料說明與建模流程{.tabset .tabset-fade .tabset-pills}

此次選擇標準普爾(以下SP500代稱)、日經平均指數(以下以N225代稱)、紐西蘭NZX50指數(以下NZ50代稱)，於2012-10-12至2022-10-12十年期間的股價日資料進行資料分析與建模。美金對紐西蘭匯率(以下以USDNZD代稱)、美金對日幣匯率(以下以USDJPY代稱)與紐西蘭對日本匯率(以下以NZDJPY代稱)，於2012-10-12到2022-10-12這段時間內的日資料，分別繪製其報酬率與對數報酬率的time plot、ACF與PACF，並對資料進行Ljung Box Test，看資料是否有序列相關或Arch效應，若有序列相關或Arch效應將更進一步建立ARMA模型或Garch模型，並於建模後做殘差檢定、分析及預測。

```{r setup, include=FALSE}
rm(list=ls(all=TRUE)) 
library(zoo)
library(xts)
library(TTR)
library(quantmod)# Finance data
library(ggplot2)
library(magrittr)
library(broom)
library(qpcR)   
library(fpp2)
library(fUnitRoots)
library(stats)
library(fGarch)

detect <- function(data,p,q){
  temp <- c()
  ord <- c()
  for (i in 0:p) {
    for (j in 0:q) {
      if (i == 0 & j==0) next
      temp <- c(temp,arima(data,order = c(i,0,j))$aic)
      ord <- rbind(ord, c(i,0,j))
    }
  }
  list(likelihood = sort(temp)[1:3],order = ord[order(temp), ][1:3,1:3]) %>% return()
}
res <- function(data,obj,cho){
  
  ACF<-acf(data, lag.max = 30,plot = FALSE)
  plot(ACF, main = paste("ACF of",obj))
  PACF<-pacf(data, lag.max = 30,plot = FALSE)
  plot(PACF, main = paste("PACF of",obj))
  
  if (cho == 't'){ACF2<-acf(data^2, lag.max = 30,plot = FALSE)
                plot(ACF2, main = paste("ACF of",obj,'^2'))}
  par(mfrow=c(1,1))
  plot(as.xts(data),main= paste("Time Plot of",obj))
  
}
knitr::opts_chunk$set(echo = FALSE,warning=FALSE)
```

# 原始資料說明與time plot、ACF、PACF繪製{.tabset .tabset-fade .tabset-pills}

- Timeplot、ACF、PACF:stationary

- Box Test:
  
  p-value<0.05 exist correlation
  
- ADF Test for NZ50:

  對原始資料做ADF test，若p-value<0.05不差分，反之，需差分。


## NZ50


```{r, echo=FALSE,warning=FALSE}
getSymbols("^NZ50", from ='2012-12-12', to = '2022-12-12')
NZ50 <- as.xts(data.frame(NZ50 = NZ50[, "NZ50.Adjusted"]))
NZ50 <- na.omit(NZ50)
names(NZ50) = c("NZ50")
index(NZ50) = as.Date(index(NZ50))
res(NZ50,'original NZ50','f')
Box.test(NZ50, lag=10, type='Ljung')
adfTest(NZ50,type = "ct")
```


## USDNZD

```{r, echo=FALSE,warning=FALSE}
getSymbols("USDNZD=X", from = '2012-10-12', to = '2022-10-12')
USDNZD<-as.xts(data.frame(`USDNZD=X` = `USDNZD=X`[, paste0("USDNZD=X.Adjusted")]))
USDNZD<-na.omit(USDNZD)
names(USDNZD) = c("USDNZD")
index(USDNZD) = as.Date(index(USDNZD))
res(USDNZD,'original USDNZD','f')

Box.test(USDNZD, lag=10, type='Ljung')
adfTest(USDNZD,type = "ct")

```

## S&P500

```{r, echo=FALSE,warning=FALSE}
getSymbols("^GSPC", from ='2012-10-12', to = '2022-10-12')
GSPC <- as.xts(data.frame(GSPC = GSPC[, "GSPC.Adjusted"]))
names(GSPC) = c("GSPC")
index(GSPC) = as.Date(index(GSPC))
res(GSPC,'original GSPC','f')

Box.test(GSPC, lag=10, type='Ljung')
adfTest(GSPC,type = "ct")
```

## USDJPY

```{r, echo=FALSE,warning=FALSE}
getSymbols("USDJPY=X", from ='2012-10-12', to = '2022-10-12')
USDJPY<-as.xts(data.frame(`USDJPY=X` = `USDJPY=X`[, paste0("USDJPY=X.Adjusted")]))
USDJPY<-na.omit(USDJPY)
names(USDJPY) = c("USDJPY")
index(USDJPY) = as.Date(index(USDJPY))
res(USDJPY,'original USDJPY','f')

Box.test(USDJPY, lag=10, type='Ljung')
adfTest(USDJPY,type = "ct")

```

# 模型建立{.tabset .tabset-fade .tabset-pills}
  
  將原始資料取對數後再進行差分，重新畫time plot、ACF、PACF，並做Ljung Box Test與ADF Test。
  從Ljung Box Test的結果與ACF、PACF觀察轉換後的資料是否存在一階與二階序列相關，若存在一階序列相關可從ACF、PACF判斷ARMA(p,q)的order p與q；若存在二階序列相關可以Garch(1,0)開始建模，並於建模後對殘差做Ljung Box Test，若存在一階與二階序列相關則結合ARMA(p,q)與Garch(m,s)進行建模。
  每次建模後若ARMA(p,q)的係數不顯著則調整ARMA(p,q)的order，若residual^2的Ljung Box存在序列相關則調整Garch(m,s)的order。

- ADF Test for diff(log(original data))
  
  將原始資料做log轉換後進行一次差分，並對log轉換後一次差分的資料做ADF Test，若p-value<0.05不差分。
  
- Series Time Plot、ACF、PACF、Series^2 ACF

  Time Plot
  ACF、PACF: order p、q
  Series^2 ACF: whether Garch effect exists or not 
  
- Box Test for diff(log(original data)) & diff(log(original data))^2

  檢定資料是否有序列相關，若p-value<0.05則資料存在序列相關，若次方後的資料p-value<0.05則可能有Garch Effect。

## NZ50

```{r, echo=FALSE,warning=FALSE}
logrt.NZ50 <- apply( log(NZ50) , 2 , diff )*100
res(logrt.NZ50,'log return of NZ50','t')
adfTest(logrt.NZ50,type = "ct")
Box.test(logrt.NZ50, lag=10, type='Ljung')
Box.test(logrt.NZ50^2, lag=10, type='Ljung')
```

資料經過對數轉換與差分過後皆通過ADF Test，但資料的一階動差與二階動差皆有序列相關性故我們選擇ARMA加上Garch建模。

根據對數轉換後的資料的ACF與PACF選取order p與q，找出此order之下AIC最小的模型，NZ50在ARMA(p,q)的order p 與 q

ARMA(p,q)order的決定先從acf/pacf plot選擇出 p & q 的最高order，再向下選出aic最低的模型，圖中可見p = 9,q = 3,故我們從(p,q)=(9,3)開始找起。
不同order下fit出的ARMA(p,q)的aic，由小到大進行排序，前三者為ARMA(4,2)、arma(5,2)、arma(4,3)。

故我們將先選用ARMA(4,2)與Garch(1,0)配適對數轉換後的資料。





### Model ARMA(4,2)+Garch(1,0) and residual diagnostic

```{r, echo=FALSE,warning=FALSE}
detect(logrt.NZ50, p = 9, q = 3)

```

```{r,echo=FALSE,warning=FALSE}
mod.NZ50 = garchFit(logrt.NZ50~arma(4,2) + garch(1,0), data = logrt.NZ50, trace = FALSE)
summary(mod.NZ50)
plot(mod.NZ50 ,which = 10)
plot(mod.NZ50 ,which = 11)
plot(mod.NZ50 ,which = 13)

```

從模型配適結果來看，係數皆顯著，但殘差的二階動差有序列相關，QQ Plot厚尾，故改用ARMA(4,2)與Garch(1,1)重新配適資料。

### Model ARMA(4,2)+Garch(1,1) and residual diagnostic
```{r, echo=FALSE,warning=FALSE}
mod.NZ50 = garchFit(logrt.NZ50~arma(4,2) + garch(1,1), data = logrt.NZ50, trace = FALSE)
summary(mod.NZ50)
plot(mod.NZ50 ,which = 10)
plot(mod.NZ50 ,which = 11)
plot(mod.NZ50 ,which = 13)

```

ARMA(4,2)與Garch(1,1)配適後的殘差一階動差與二階動差皆無序列相關，但從QQ Plot來看，資料呈現厚尾的現象，且常態檢定Shapiro Test拒絕虛無假設，表示殘差非常態分配，故改配適假設殘差來自skew T分配的ARMA(4,2)與Garch(1,1)的模型。


### Model ARMA(4,2)+Garch(1,1) and  assume residual is from skew T distribution

```{r, echo=FALSE,warning=FALSE}

mod.NZ50 = garchFit(logrt.NZ50~arma(4,2) + garch(1,1), data = logrt.NZ50, trace = FALSE,cond.dist = 'std')
summary(mod.NZ50)
plot(mod.NZ50 ,which = 9)
plot(mod.NZ50 ,which = 10)
plot(mod.NZ50 ,which = 11)
plot(mod.NZ50 ,which = 13)
residuals(mod.NZ50, standardize = T) %>% density() %>% plot(.,main="Standardized Residuals of NZ50", xlab="x", ylim = c(0,0.6))# right skew
curve(dstd(x,nu = 7.549839), from = -4, to = 6, ylab = "", add=T, col = "red")
legend("topright", legend=c("residual", "std"),
       col=c("black", "red"), lty=1, cex=1.2)
```

配適假設殘差來自skew T分配的ARMA(4,2)與Garch(1,1)的模型後，不僅殘差一階與二階動差皆無序列相關，且QQ Plot的資料點也更貼合斜線，KS Test的結果也不拒絕，此模型有通過殘差假設，故我們選用來自 skew T分配的ARMA(4,2)與Garch(1,1)的模型配適對數轉換後的資料。

### KS Test for residual
```{r,echo=FALSE,warning=FALSE}
set.seed(110225013)
res.NZ50 = residuals(mod.NZ50, standardize = T)
sstd<-rstd(1000, nu =   7.549839)
ks.test(res.NZ50,sstd)

```

## USDNZD

```{r, echo=FALSE,warning=FALSE}

logrt.USDNZD<-apply( log(USDNZD) , 2 , diff )*100
res(logrt.USDNZD,'log return of USDNZD','t')
adfTest(logrt.USDNZD,type = "ct")
Box.test(logrt.USDNZD, lag=10, type='Ljung')
Box.test(logrt.USDNZD^2, lag=10, type='Ljung')

```

資料經過對數轉換與差分過後皆通過ADF Test，資料的一階動差也沒有序列相關，但二階動差有序列相關性故我們選擇從Garch(1,0)配適模型。

### Model Garch(1,0) and residual diagnostic

```{r, echo=FALSE,warning=FALSE}
mod.USDNZD<-garchFit(logrt.USDNZD~ garch(1,0), data = logrt.USDNZD, trace = FALSE)
summary(mod.USDNZD)
plot(mod.USDNZD ,which = 10)
plot(mod.USDNZD ,which = 11)
plot(mod.USDNZD ,which = 13)
```

從Garch(1,0)的模型配適結果可以看到係數皆為顯著的，但殘差的一階動差與二階動差皆具有序列相關性，故我們重新配適Garch(1,1)。

### Model Garch(1,1) and residual diagnostic

```{r, echo=FALSE,warning=FALSE}
mod.USDNZD<-garchFit(logrt.USDNZD~ garch(1,1), data = logrt.USDNZD, trace = FALSE)
summary(mod.USDNZD)
plot(mod.USDNZD ,which = 10)
plot(mod.USDNZD ,which = 11)
plot(mod.USDNZD ,which = 13)

```

從Garch(1,1)的模型配適結果可以看到係數皆為顯著的，一階動差無序列相關，但殘差的二階動差具有序列相關性，且QQ Plot也呈現厚尾的狀態，故我們重新配適假設殘差來自標準T分配的Garch(2,1)。

### Model Garch(1,1) and residual diagnostic(assume residual is from standardize T distribution)

```{r, echo=FALSE,warning=FALSE}
mod.USDNZD<-garchFit(logrt.USDNZD~ garch(2,1), data = logrt.USDNZD, trace = FALSE,cond.dist = 'std')
summary(mod.USDNZD)
plot(mod.USDNZD ,which = 10)
plot(mod.USDNZD ,which = 11)
plot(mod.USDNZD ,which = 13)

```

由於Garch(2,1)的係數不如Garch(1,1)的模型顯著，雖然殘差的一階動差無序列相關，但殘差的二階動差具有序列相關性，且QQ Plot也呈現厚尾的狀態，故我們將資料逐年檢查，去除有問題的年份後重新配適Garch(1,1)。

### Refit Model Garch(1,1) and residual diagnostic since 2013-10-12 to 2017-10-12

```{r, echo=FALSE,warning=FALSE}

getSymbols("USDNZD=X", from = '2013-10-12', to = '2017-10-12')
USDNZD<-as.xts(data.frame(`USDNZD=X` = `USDNZD=X`[, paste0("USDNZD=X.Adjusted")]))
USDNZD<-na.omit(USDNZD)
names(USDNZD) = c("USDNZD")
index(USDNZD) = as.Date(index(USDNZD))
res(USDNZD,'original USDNZD','f')

Box.test(USDNZD, lag=10, type='Ljung')
adfTest(USDNZD,type = "ct")

logrt.USDNZD<-apply( log(USDNZD) , 2 , diff )*100
res(logrt.USDNZD,'log return of USDNZD','t')
adfTest(logrt.USDNZD,type = "ct")
Box.test(logrt.USDNZD, lag=10, type='Ljung')
Box.test(logrt.USDNZD^2, lag=10, type='Ljung')

mod.USDNZD<-garchFit(logrt.USDNZD~ garch(1,1), data = logrt.USDNZD, trace = FALSE)
summary(mod.USDNZD)
plot(mod.USDNZD ,which = 9)
plot(mod.USDNZD ,which = 10)
plot(mod.USDNZD ,which = 11)
plot(mod.USDNZD ,which = 13)


```

去除有問題的資料區間後，重新抓取2013-10-12到2017-10-12之間的資料，進行對數轉換與差分後配適Garch(1,1)，其殘差一階與二階動差皆無序列相關且殘差亦符合常態假設，故若僅用此區間段的資料配適Garch(1,1)是可行的。



## S&P500

```{r,echo=FALSE,warning=FALSE}
logrt.GSPC<-apply( log(GSPC) , 2 , diff )*100
res(logrt.GSPC,'log return of GSPC','t')
adfTest(logrt.GSPC,type = "ct")
Box.test(logrt.GSPC, lag=10, type='Ljung')
Box.test(logrt.GSPC^2, lag=10, type='Ljung')
```

資料經過對數轉換與差分過後皆通過ADF Test，但資料的一階動差與二階動差皆有序列相關性故我們選擇ARMA加上Garch建模。

根據對數轉換後的資料的ACF與PACF選取order p與q，找出此order之下AIC最小的模型，NZ50在ARMA(p,q)的order p 與 q

ARMA(p,q)order的決定先從acf/pacf plot選擇出 p & q 的最高order，再向下選出aic最低的模型，圖中可見p = q = 9，為了避免使用過多參數，故我們從(p,q)=(5,5)開始找起。
不同order下fit出的ARMA(p,q)的aic，由小到大進行排序，前三者為ARMA(5,5)、arma(4,4)、arma(4,5)。



### Model ARMA(1,1)+Garch(1,1)  and residual diagnostic(assume residual form skewed generalized distribution)

我們先選用ARMA(5,5)與Garch(1,0)配適對數轉換後的資料
當係數出現NaN或不顯著，我們便修改模型 arma order 至 (1,1) 而後因 garch effect 為消除完全而將 garch order 至 (1,1)，最後透過K-S test診斷標準化殘差是否符合假設分配，發現標準化殘差服從skewed generalized distribution。



```{r,echo=FALSE,warning=FALSE}
detect(logrt.GSPC ,5, 5)
```


```{r,echo=FALSE,warning=FALSE}
fit.GSPC <- garchFit(logrt.GSPC~arma(1,1) + garch(1,1), data = logrt.GSPC, trace = F,cond.dist = "sged")
fit.GSPC %>% summary()
plot(fit.GSPC,which=9)
plot(fit.GSPC,which=10)
plot(fit.GSPC,which=11)
plot(fit.GSPC,which=13)

ks.test(residuals(fit.GSPC, standardize = T),rsged(250,nu = 1.332484 , xi = 0.868107))
residuals(fit.GSPC, standardize = T) %>% density() %>% plot(.,main="Standardized Residuals of SP500", xlab="x", ylim = c(0,0.6))# right skew
curve(dsged(x,nu = 1.332484 , xi = 0.868107), from = -4, to = 6, ylab = "", add=T, col = "red")
legend("topright", legend=c("residual", "sged"),
       col=c("black", "red"), lty=1, cex=1.2)

```

## USDJPY

```{r,echo=FALSE,warning=FALSE}
logrt.USDJPY<-apply( log(USDJPY) , 2 , diff )*100
res(logrt.USDJPY,'log return of USDJPY','t')
adfTest(logrt.USDJPY,type = "ct")
Box.test(logrt.USDJPY, lag=10, type='Ljung')
Box.test(logrt.USDJPY^2, lag=10, type='Ljung')
```

資料經過對數轉換與差分過後皆通過ADF Test，但資料的一階動差與二階動差皆有序列相關性故我們選擇ARMA加上Garch建模。

根據對數轉換後的資料的ACF與PACF選取order p與q，找出此order之下AIC最小的模型，NZ50在ARMA(p,q)的order p 與 q

ARMA(p,q)order的決定先從acf/pacf plot選擇出 p & q 的最高order，再向下選出aic最低的模型，圖中可見p = q = 5，故我們從(p,q)=(5,5)開始找起。
不同order下fit出的ARMA(p,q)的aic，由小到大進行排序，前三者為ARMA(2,4)、arma(4,2)、arma(3,5)。

故我們將先選用ARMA(2,4)與Garch(1,0)配適對數轉換後的資料



### Model ARMA(1,1)+Garch(1,1)  and residual diagnostic(assume residual form skewed T distribution)

我們先選用ARMA(2,4)與Garch(1,0)配適對數轉換後的資料
當係數出現NaN或不顯著，我們便修改模型 arma order 至 (1,1) 而後因 garch effect 為消除完全而將 garch order 至 (1,1)，最後透過K-S test診斷標準化殘差是否符合假設分配，發現標準化殘差服從skewed T distribution。


```{r,warning=FALSE}
detect(logrt.USDJPY, 5, 5)
```

```{r,echo=FALSE,warning=FALSE}
fit.USDJPY <- garchFit(logrt.USDJPY~arma(1,1) + garch(1,1),data = logrt.USDJPY, trace = F,cond.dist = "sstd")
fit.USDJPY %>% summary()
plot(fit.USDJPY,which=9)
plot(fit.USDJPY,which=10)
plot(fit.USDJPY,which=11)
plot(fit.USDJPY,which=13)
USJP.resid <- residuals(fit.USDJPY, standardize = T)
ks.test(USJP.resid,rsstd(1000,nu = 5.984396 , xi = 0.968644))
USJP.resid %>% density() %>% plot(.,main="Standardized Residuals of USD/JPY", xlab="x", ylim = c(0,0.6))# right skew
curve(dsstd(x,nu = 5.984396 , xi = 0.968644), from = -4, to = 6, ylab = "", add=T, col = "red")
legend("topright", legend=c("residual", "sstd"),
       col=c("black", "red"), lty=1, cex=1.2)
```


```{r,echo=FALSE,warning=FALSE}
```


```{r,echo=FALSE,warning=FALSE}
```

```{r,echo=FALSE,warning=FALSE}
```



# 結論{.tabset .tabset-fade .tabset-pills}
 
 
## NZ50

## USDNZD
